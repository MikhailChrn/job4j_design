package ru.job4j.memory;

/**
 * Запуск программы начинается с метода main(). Под него в стеке выделяется память,
 * в которую записываются переменные и ссылки метода main(),
 * а в куче будут созданы объекты Object и Example.
 * Красные линии - это ссылки. Например, ссылка args в Stack ссылается на объект типа String[] в Heap.
 * args - это массив аргументов, с которыми запускается программа.
 * Даже если вы не задавали эти аргументы при запуске программы,
 * сигнатура метода main (String args[]) говорит о том,
 * что ссылка args в любом случае будет создана и будет храниться в стеке в методе main().
 *
 * В следующей строке
 * вызывается метод action() изнутри метода main(), у которого сейчас находится управление.
 * При выполнении данной операции состояние выполнения метода main() будет заморожено,
 * а управление будет передано методу action().
 * То есть если метод вызывает другой метод, то вызывающий метод приостанавливается в частично завершенном состоянии.
 * Под вызванный метод будет выделена новая область памяти в стеке,
 * куда будут записаны переменные и ссылки метода action(), а в куче будут созданы объекты,
 * на которые ссылаются ссылки метода action().
 * Также в область памяти метода action() будут записаны ссылка параметра parameter (копия ссылки obj)
 * и переменная this (копия ссылки example), которая ссылается на объект класса Example из метода main():
 *
 * После того, как последний вызванный метод (верхний в стеке) закончил выполнение всех своих команд,
 * управление передается предыдущему методу, из которого он был вызван,
 * и работа программы продолжается с того момента, на котором предыдущий метод был приостановлен.
 */

public class Example {
    public static void main(String[] args) {
        int x = 0;
        Object obj = new Object();
        Example example = new Example();
        example.action(obj);
    }

    public void action(Object parameter) {
        String str = parameter.toString();
        System.out.println(str);
    }
}